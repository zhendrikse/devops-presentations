<!DOCTYPE html>
<html>
  <head>
    <title>Stack in Python with Mamba using TDD</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">
class: inverse
layout: true
---
class: center, middle

# Implementing a stack 

## in Python with Mamba

([using replit.com](https://replit.com/@zwh/Stack-with-TDD-Python-and-Mamba#README.md))

---
# First verify we can write a test
```python
from mamba import description, it
from expects import expect, equal

with description("Nothing") as self:
  with it("should do noting"):
    expect(True).to(equal(True))
```
--
###Which results in:
```
$ mamba --format=documentation *_spec.py
Nothing
  &#10003; it should do nothing

1 examples ran in 0.0460 seconds
$
```
---
# Let's focus on our stack
```python
from mamba import description, it
from expects import expect, equal
from stack import Stack

with description(Stack) as self:
  with it("should do noting"):
    expect(True).to(equal(True))
```
--

```python
class Stack:
  pass
```

---

## An empty stack should be ... empty?

```python
with description(Stack) as self:
  with context("When new"):
    with it("should be empty"):
      myStack = Stack()
      expect(myStack.isEmpty()).to(equal(True))
```
--

```python
class Stack:
  pass

  def isEmpty(self) -&gt; bool:
    return True
```

---

# Our updated plan

- ~~Start with an empty stack~~ &#10003;
- Define pop on an empty stack
- Define push on an empty stack
- Define pop on a non-empty stack
- Define multiple pushes and pops

---
## Pop on an empty stack

```python
    ...
    with it("should throw an exception on a pop operation"):
      myStack = Stack()
      expect(myStack.pop).to(raise_error(KeyError))
...
```
--

```python
class Stack:
  def isEmpty(self) -&gt; bool:
    return True

  def pop(self) -&gt; int:
    raise KeyError("Stack underflow")
```

---
## Red, green, ... refactor!

### DRY

```python
from mamba import description, it, context, before
from expects import expect, equal, raise_error
from stack import Stack

with description(Stack) as self:
  with before.each:
    self.myStack = Stack()

  with context("When new"):
    with it("should be empty"):
      expect(self.myStack.isEmpty()).to(equal(True))

    with it("should throw an exception on a pop operation"):
      expect(self.myStack.pop).to(raise_error(KeyError))
```

---

# Our updated plan

- ~~Start with an empty stack~~ &#10003;
- ~~Define pop on an empty stack~~ &#10003;
- Define push on an empty stack
- Define pop on a non-empty stack
- Define multiple pushes and pops

---
## Push something onto the stack

```python
    ...
    with it("should not be empty after a push operation"):
      self.myStack.push(8)
      expect(self.myStack.isEmpty()).to(equal(False))
```
--

```python
class Stack:
  def __init__(self):
    self.is_empty: bool = True

  def isEmpty(self) -&gt; bool:
    return self.is_empty

  def pop(self) -&gt; int:
    raise KeyError("Stack underflow")

  def push(self, newElement:int) -&gt; None:
    self.is_empty = False
```

---
## ... And pop it from the stack

```python
    ...
    with it("should be empty after one push and one pop"):
      self.myStack.push(8)
      self.myStack.pop()
      expect(self.myStack.isEmpty()).to(equal(True))
```

--

```python
  ...
  def pop(self) -&gt; int:
    if (self.is_empty == True):
      raise KeyError("Stack underflow")
    self.is_empty = True
  ...

```

---
## DRY revisited

```python
with description(Stack) as self:
  ...

  with context("When new"):
    ...

  with context("When has one element pushed"):
    with before.each:
      self.myStack.push(8)

    with it("should not be empty"):
      expect(self.myStack.isEmpty()).to(equal(False))

    with it("should be empty after one pop"):
      self.myStack.pop()
      expect(self.myStack.isEmpty()).to(equal(True))
```

---

# Our updated plan

- ~~Start with an empty stack~~ &#10003;
- ~~Define pop on an empty stack~~ &#10003;
- ~~Define push on an empty stack~~ &#10003;
- Define pop on a non-empty stack
- Define multiple pushes and pops


---
## Two pushes and one pop!?

```javascript
  ...
  it("should not be empty after 2 pushes and 1 pop", function() {
    myStack.push(8)
    myStack.push(9)
    myStack.pop()
    expect(myStack.isEmpty()).toEqual(false);
  })
  ...
```

---
## Introduction of size inevitable!

```javascript
class Stack {
  constructor() {
    this.stackIsEmtpy = true
    this.size = 0
  }

  isEmpty() {
    return this.size == 0
  }

  pop() {
    if (this.stackIsEmtpy)
      throw new Error("Stack underflow")
    this.stackIsEmtpy = true
    --this.size
  }

  push(newElement) {
    this.stackIsEmtpy = false
    this.size++
  }
}
```

--- 
## We can refactor

---

## Red, green, ... refactor!

```javascript
class Stack {
  constructor() {
    this.size = 0
  }

  isEmpty() {
    return this.size == 0
  }

  pop() {
    if (this.isEmpty())
      throw new Error("Stack underflow")
    --this.size
  }

  push(newElement) {
    this.size++
  }
}
```

---
## Does the pop actually work?

```javascript
...
    it("should pop the pushed element", function () {
      expect(myStack.pop()).toEqual(8)
    })
....
```
--

```javascript
...
  pop() {
    if (this.isEmpty())
      throw new Error("Stack underflow")
    --this.size
    return 8
  }
...
```

---

# Our updated plan

- ~~Start with an empty stack~~ &#10003;
- ~~Define pop on an empty stack~~ &#10003;
- ~~Define push on an empty stack~~ &#10003;
- ~~Define pop on a non-empty stack~~ &#10003;
- Define multiple pushes and pops

---
## Let's extend the test

```javascript
...
    it("should pop the pushed element", function () {
      expect(myStack.pop()).toEqual(8)
      myStack.push(9)
      expect(myStack.pop()).toEqual(9)
    })
....
```

--

```javascript
class Stack {
  constructor() {
    this.size = 0
    this.element = -1
  }

  isEmpty() { return this.size == 0 }

  pop() {
    if (this.isEmpty())
      throw new Error("Stack underflow")
    --this.size
    return this.element;
  }

  push(newElement) {
    this.size++
    this.element = newElement
  }
}
```

---

## Multiple push and pop

```javascript
    it("should pop 2 elements after another push", function() {
      myStack.push(9)
      expect(myStack.pop()).toEqual(9)
      expect(myStack.pop()).toEqual(8)
    })
```

```javascript
class Stack {
  constructor() {
    this.size = 0
    this.element = []
  }

  isEmpty() { return this.size == 0 }

  pop() {
    if (this.isEmpty())
      throw new Error("Stack underflow")
    
    return this.element[--this.size];
  }

  push(newElement) {
    this.element[this.size++] = newElement
  }
}
```



    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
var slideshow = remark.create({
  // Customize slide number label, either using a format string..
  slideNumberFormat: 'Slide %current% of %total%',
  // .. or by using a format function
  slideNumberFormat: function (current, total) {
    return 'Slide ' + current + ' of ' + total;
  },

  countIncrementalSlides: false,
  highlightLanguage: 'java',
  highlightStyle: 'monokai',
}); 
    </script>
  </body>
</html>
